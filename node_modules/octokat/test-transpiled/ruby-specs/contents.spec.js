'use strict';

/* eslint-env mocha */
var _require = require('chai'),
    expect = _require.expect;

var _require2 = require('../test-config'),
    client = _require2.client,
    LONG_TIMEOUT = _require2.LONG_TIMEOUT,
    test_repo = _require2.test_repo;

// NodeJS does not have a btoa


var btoa = null;

if (typeof window !== 'undefined' && window !== null) {
  btoa = window.btoa;
  // Use the `Buffer` if available (NodeJS)
} else if (typeof global !== 'undefined' && global !== null) {
  btoa = function btoa(str) {
    var buffer = new global['Buffer'](str, 'binary');
    return buffer.toString('base64');
  };
} else {
  throw new Error('Native btoa function or Buffer is missing');
}

describe('Contents', function () {
  this.timeout(LONG_TIMEOUT);

  it('returns the default readme', function () {
    return client.repos('octokit/octokit.rb').readme.read().then(function (readme) {});
  });
  // expect(readme.encoding).to.equal("base64")
  // expect(readme.type).to.equal("file")

  it('returns the contents of a file', function () {
    return client.repos('octokit/octokit.rb').contents('lib/octokit.rb').read().then(function (contents) {});
  });
  // expect(contents.encoding).to.equal("base64")
  // expect(contents.type).to.equal("file")

  // it "returns the headers of the request", ->
  //   client.repos('octokit/octokit.rb').tarball('master').fetch()
  //   .then(null, (err) -> console.log err)
  //   .then (archive_link) ->
  //     expect(archive_link).to.equal('https://codeload.github.com/octokit/octokit.rb/legacy.tar.gz/master')

  context('With a file', function () {
    beforeEach(function (done) {
      var removeFile = function removeFile(octoPartial, content) {
        var config = {
          sha: content.sha,
          message: 'Removing as prep for testing'
        };
        return octoPartial.remove(config);
      };

      // If the file exists, remove it. Otherwise, done.
      function removeFirst(content1) {
        function removeSecond() {
          var octoPartial2 = client.repos(test_repo).contents('test_delete.txt');
          octoPartial2.fetch()
          /* eslint handle-callback-err: "off" */
          .then(function (content) {
            removeFile(octoPartial2, content).then(function (x) {
              return done();
            });
          }, function (err) {
            return done();
          });
        }
        removeFile(octoPartial, content1).then(removeSecond, removeSecond);
      }
      var octoPartial = client.repos(test_repo).contents('test_create.txt');
      octoPartial.fetch()
      /* eslint handle-callback-err: "off" */
      .then(removeFirst, removeFirst);

      // In Mocha 3, if the returned value is a promise then it will complain that
      // we have specified a done() callback _and_ returned a promise.
      // So, since this test should always succeed even if there is no file (to delete)
      // just return null so Mocha does not complain.
      return null;
    });

    it('creates repository contents at a path', function () {
      var repo = client.repos(test_repo);
      return repo.fetch().then(function (_ref) {
        var defaultBranch = _ref.defaultBranch;

        return repo.branches(defaultBranch).fetch().then(function (_ref2) {
          var commit = _ref2.commit;

          var config = {
            message: 'I am commit-ing',
            content: btoa('Here be the content\n')
          };
          return repo.contents('test_create.txt').add(config).then(null, function (err) {
            console.log(err);throw new Error(err);
          }).then(function (response) {
            return expect(response.commit.sha).to.match(/[a-z0-9]{40}/);
          });
        });
      });
    });

    it('updates repository contents at a path', function () {
      // Prep work (from previous test)
      var repo = client.repos(test_repo);
      return repo.fetch().then(function (_ref3) {
        var defaultBranch = _ref3.defaultBranch;

        return repo.branches(defaultBranch).fetch().then(function (_ref4) {
          var commit = _ref4.commit;

          var config = {
            message: 'I am commit-ing',
            content: btoa('Here be the content\n')
          };
          return repo.contents('test_create.txt').add(config).then(null, function (err) {
            console.log(err);throw new Error(err);
          }).then(function (response) {

            // Test Start
            var config = {
              sha: response.content.sha,
              message: 'I am commit-ing',
              content: btoa('Here be moar content')
            };
            return client.repos(test_repo).contents('test_create.txt').add(config).then(function (response2) {
              return expect(response2.commit.sha).to.match(/[a-z0-9]{40}/);
            });
          });
        });
      });
    });

    it('deletes repository contents at a path', function () {
      // Prep work (from previous test)
      var repo = client.repos(test_repo);
      return repo.fetch().then(function (_ref5) {
        var defaultBranch = _ref5.defaultBranch;

        return repo.branches(defaultBranch).fetch().then(function (_ref6) {
          var commit = _ref6.commit;

          var config = {
            message: 'I am commit-ing for removal',
            content: btoa('Here be the content\n')
          };
          return repo.contents('test_delete.txt').add(config).then(null, function (err) {
            console.log(err);throw new Error(err);
          }).then(function (response) {
            expect(response.commit.sha).to.match(/[a-z0-9]{40}/);

            // Test Start
            var config = {
              sha: response.content.sha,
              message: 'I am rm-ing'
            };
            return client.repos(test_repo).contents('test_delete.txt').remove(config).then(function (response) {
              expect(response.url).is.a('string');
            });
          });
        });
      });
    });
  });
});

// TODO: have a non-boolean form of remove()
// expect(response.commit.sha).to match(/[a-z0-9]{40}/)
//# sourceMappingURL=contents.spec.js.map