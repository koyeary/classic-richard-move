'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Request Function
// ===============================
//
// Generates the actual HTTP requests to GitHub.
// Handles ETag caching, authentication headers, boolean requests, and paged results

// # Construct the request function.
// It contains all the auth credentials passed in to the client constructor

module.exports = function () {
  function Requestor(fetchImpl, userAgent, usePostInsteadOfPatch) {
    _classCallCheck(this, Requestor);

    this._fetchImpl = fetchImpl;
    // Set the `User-Agent` because it is required and NodeJS
    // does not send one by default.
    // See http://developer.github.com/v3/#user-agent-required
    this._userAgent = userAgent || 'octokat.js';
    this._usePostInsteadOfPatch = usePostInsteadOfPatch;
  }

  _createClass(Requestor, [{
    key: 'request',
    value: function request(method, path, data, isRaw, isBase64, isBoolean, contentType, acceptHeader) {
      if (!/^http/.test(path)) {
        throw new Error('BUG: All Paths must be absolute (start with https://)');
      }

      var headers = {
        'Accept': isRaw ? 'application/vnd.github.raw' : acceptHeader || 'application/json',
        'User-Agent': this._userAgent
      };

      var fetchArgs = {
        // TODO: add the followRedirects flag
        method: method,
        headers: headers,
        body: !isRaw && data && JSON.stringify(data) || data
      };

      return this._fetchImpl(path, fetchArgs).then(function (response) {
        // Collect any response headers into an object
        var additional = {};
        if (response.headers.get('X-RateLimit-Limit')) {
          var rateLimit = parseFloat(response.headers.get('X-RateLimit-Limit'));
          var rateLimitRemaining = parseFloat(response.headers.get('X-RateLimit-Remaining'));
          var rateLimitReset = parseFloat(response.headers.get('X-RateLimit-Reset'));
          // Reset time is in seconds, not milliseconds
          // if rateLimitReset
          //   rateLimitReset = new Date(rateLimitReset * 1000)
          additional.rate = {
            remaining: rateLimitRemaining,
            limit: rateLimit,
            reset: rateLimitReset
          };

          if (response.headers.get('X-OAuth-Scopes')) {
            additional.scopes = response.headers.get('X-OAuth-Scopes').split(', ');
          }
        }

        // Massage the value we return
        var valuePromise = void 0;

        if (isBoolean && response.status === 204) {
          // If the request is a boolean yes/no question GitHub will indicate
          // via the HTTP Status of 204 (No Content) or 404 instead of a 200.
          valuePromise = Promise.resolve(true);
        } else if (isBoolean && response.status === 404) {
          valuePromise = Promise.resolve(false);
        } else if (response.status >= 200 && response.status < 300 || response.status === 304 || response.status === 302 || response.status === 0) {
          // If it was a boolean question and the server responded with 204 ignore.

          // If the status was 304 then let the cache handler pick it up. leave data blank
          if (response.status === 304) {
            valuePromise = Promise.resolve(null);
          } else {
            // TODO: use a blob if we are expecting a binary

            var _contentType = response.headers.get('content-type') || '';

            // Use .indexOf instead of .startsWith because PhantomJS does not support .startsWith
            if (_contentType.indexOf('application/json') === 0) {
              valuePromise = response.json();
            } else {
              // Other contentTypes:
              // - 'text/plain'
              // - 'application/octocat-stream'
              // - 'application/vnd.github.raw'
              valuePromise = response.text();
            }
          }
        } else {
          // TODO: Reject the Promise
          valuePromise = response.text().then(function (text) {
            return Promise.reject(new Error(text + ' ' + fetchArgs.method + ' ' + path + ' Status: ' + response.status));
          });
        }

        return valuePromise.then(function (value) {
          // TODO: return new OctokatResponse()
          return {
            value: value,
            request: {
              url: path,
              method: fetchArgs.method,
              headers: fetchArgs.headers,
              body: fetchArgs.body
            },
            response: {
              status: response.status,
              statusText: response.statusText,
              headers: response.headers,
              ok: response.ok,
              size: response.size,
              timeout: response.timeout
            },
            additional: additional
          };
        });
      });
    }
  }]);

  return Requestor;
}();
//# sourceMappingURL=request.js.map